\doxysection{Lista de clases}
Lista de las clases, estructuras, uniones e interfaces con una breve descripción\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_animation}{OSK\+::\+GRAPHICS\+::\+Animation}} \\*Animación para un modelo 3D. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_animation}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_animation_channel}{OSK\+::\+GRAPHICS\+::\+Animation\+Channel}} \\*Información sobre el valor de una transformación individual de la animación. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_animation_channel}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_animation_sampler}{OSK\+::\+GRAPHICS\+::\+Animation\+Sampler}} \\*Incluye los valores de transform y timestamps de la animación de un hueso, y cómo interpolarlos. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_animation_sampler}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_animation_skin}{OSK\+::\+GRAPHICS\+::\+Animation\+Skin}} \\*Indica cómo aplicar una animación a un modelo animado. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_animation_skin}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_animator}{OSK\+::\+GRAPHICS\+::\+Animator}} \\*Componente (no \mbox{\hyperlink{namespace_o_s_k_1_1_e_c_s}{ECS}}) de un modelo animado }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_animator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_anim_mesh_loader}{OSK\+::\+ASSETS\+::\+Anim\+Mesh\+Loader}} \\*}{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_anim_mesh_loader}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_asset_manager}{OSK\+::\+ASSETS\+::\+Asset\+Manager}} \\*El \mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_asset_manager}{Asset\+Manager}} se encarga de manejar los loaders de los assets y los lifetimes de los assets }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_asset_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_bit_set}{OSK\+::\+Bit\+Set}} \\*Un bitset representa un array de bits. }{\pageref{class_o_s_k_1_1_bit_set}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_bloom_pass}{OSK\+::\+GRAPHICS\+::\+Bloom\+Pass}} \\*Clase auxiliar que permite una capa de bloom / resplandor }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_bloom_pass}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_bottom_level_acceleration_structure_vulkan}{OSK\+::\+GRAPHICS\+::\+Bottom\+Level\+Acceleration\+Structure\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_bottom_level_acceleration_structure_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_camera_component2_d}{OSK\+::\+ECS\+::\+Camera\+Component2D}} \\*Cámara para un mundo de dos dimensiones. }{\pageref{class_o_s_k_1_1_e_c_s_1_1_camera_component2_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_camera_component3_d}{OSK\+::\+ECS\+::\+Camera\+Component3D}} \\*Cámara para un mundo tridimensional. }{\pageref{class_o_s_k_1_1_e_c_s_1_1_camera_component3_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_color}{OSK\+::\+Color}} \\*Representa un color en formato RGBA. }{\pageref{class_o_s_k_1_1_color}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_list_dx12}{OSK\+::\+GRAPHICS\+::\+Command\+List\+Dx12}} \\*Una lista de comandos contiene una serie de comandos que serán enviados a la GPU para su ejecución. La lista es creada por una pool de comandos, y se introduce en una cola de comandos para su ejecución }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_list_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_list_vulkan}{OSK\+::\+GRAPHICS\+::\+Command\+List\+Vulkan}} \\*Una lista de comandos contiene una serie de comandos que serán enviados a la GPU para su ejecución. La lista es creada por una pool de comandos, y se introduce en una cola de comandos para su ejecución }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_list_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_pool_dx12}{OSK\+::\+GRAPHICS\+::\+Command\+Pool\+Dx12}} \\*Una pool de comandos se encarga de crear una serie de listas de comandos }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_pool_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_pool_vulkan}{OSK\+::\+GRAPHICS\+::\+Command\+Pool\+Vulkan}} \\*Una pool de comandos se encarga de crear una serie de listas de comandos }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_pool_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_queue_dx12}{OSK\+::\+GRAPHICS\+::\+Command\+Queue\+Dx12}} \\*Una cola de comandos almacena todas las listas de comandos que se envían a la GPU }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_queue_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_queue_vulkan}{OSK\+::\+GRAPHICS\+::\+Command\+Queue\+Vulkan}} \\*Una cola de comandos almacena todas las listas de comandos que se envían a la GPU }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_command_queue_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_component_container}{OSK\+::\+ECS\+::\+Component\+Container$<$ TComponent $>$}} \\*Contenedor para el dynamic array de componentes del tipo dado. Se encarga de manejar la introducción y eliminación de componentes. Los componentes se almacenan en memoria contínua. }{\pageref{class_o_s_k_1_1_e_c_s_1_1_component_container}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_component_manager}{OSK\+::\+ECS\+::\+Component\+Manager}} \\*Se encarga de manejar la creación y eliminación de componentes. Guarda un \mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_component_container}{Component\+Container}} por cada tipo de componente registrado. }{\pageref{class_o_s_k_1_1_e_c_s_1_1_component_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_compute_pipeline_dx12}{OSK\+::\+GRAPHICS\+::\+Compute\+Pipeline\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_compute_pipeline_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_compute_pipeline_vulkan}{OSK\+::\+GRAPHICS\+::\+Compute\+Pipeline\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_compute_pipeline_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_constexpr_bit_set}{OSK\+::\+Constexpr\+Bit\+Set$<$ size $>$}} \\*Un bitset representa un array de bits }{\pageref{class_o_s_k_1_1_constexpr_bit_set}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_cubemap_texture}{OSK\+::\+ASSETS\+::\+Cubemap\+Texture}} \\*Representa una textura para un cubemap. Se puede usar para renderizar un skybox. }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_cubemap_texture}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_cubemap_texture_loader}{OSK\+::\+ASSETS\+::\+Cubemap\+Texture\+Loader}} }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_cubemap_texture_loader}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_descriptor_block_dx12}{OSK\+::\+GRAPHICS\+::\+Descriptor\+Block\+Dx12}} \\*Estructura para ayudar al manejo de descriptor heaps. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_descriptor_block_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_descriptor_dx12}{OSK\+::\+GRAPHICS\+::\+Descriptor\+Dx12}} }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_descriptor_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_descriptor_layout_vulkan}{OSK\+::\+GRAPHICS\+::\+Descriptor\+Layout\+Vulkan}} \\*Wrapper de un Vk\+Descrpitor\+Set\+Layout. Se encarga de crear el layout a partir del \mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout_slot}{Material\+Layout\+Slot}}. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_descriptor_layout_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_descriptor_pool_vulkan}{OSK\+::\+GRAPHICS\+::\+Descriptor\+Pool\+Vulkan}} \\*Wrapper de un Vk\+Descriptor\+Pool. Se encarga de crear el pool a partir del \mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout_slot}{Material\+Layout\+Slot}}. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_descriptor_pool_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_directional_light}{OSK\+::\+GRAPHICS\+::\+Directional\+Light}} \\*Representa una luz direccional. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_directional_light}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_dynamic_array}{OSK\+::\+Dynamic\+Array$<$ T $>$}} \\*Dynamic array\+: array que puede cambiar de tamaño }{\pageref{class_o_s_k_1_1_dynamic_array}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_engine}{OSK\+::\+Engine}} \\*Clase principal de OSKengine. }{\pageref{class_o_s_k_1_1_engine}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_entity_component_system}{OSK\+::\+ECS\+::\+Entity\+Component\+System}} \\*Entity-\/\+Component-\/\+System es un paradigma de programación en el cual los objetos se dividen en 3 partes diferenciables\+: }{\pageref{class_o_s_k_1_1_e_c_s_1_1_entity_component_system}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_vertex_info_1_1_entry}{OSK\+::\+GRAPHICS\+::\+Vertex\+Info\+::\+Entry}} \\*Información de un atributo. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_vertex_info_1_1_entry}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_i_o_1_1_file_i_o}{OSK\+::\+IO\+::\+File\+IO}} \\*Clase que actúa de interfaz para la lectura y escritura de atchivos. }{\pageref{class_o_s_k_1_1_i_o_1_1_file_i_o}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_font}{OSK\+::\+ASSETS\+::\+Font}} \\*Representa una fuente\+: un asset que almacena una fuente que nos permite renderizar texto }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_font}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_font_character}{OSK\+::\+ASSETS\+::\+Font\+Character}} \\*Información básica de un carácter de una instancia de fuente en concreto }{\pageref{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_font_character}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_font_instance}{OSK\+::\+ASSETS\+::\+Font\+Instance}} \\*Representa una fuente que ha sido generada con un tamaño específico. Cada tamaño de fuente tendrá su propia imagen cargada. }{\pageref{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_font_instance}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_font_loader}{OSK\+::\+ASSETS\+::\+Font\+Loader}} }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_font_loader}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_fxaa_pass}{OSK\+::\+GRAPHICS\+::\+Fxaa\+Pass}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_fxaa_pass}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_game_object_manager}{OSK\+::\+ECS\+::\+Game\+Object\+Manager}} \\*Se encarga de registrar y eliminar Game\+Objects. }{\pageref{class_o_s_k_1_1_e_c_s_1_1_game_object_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_i_o_1_1_gamepad_state}{OSK\+::\+IO\+::\+Gamepad\+State}} \\*Representa el estado actual de un gamepad conectado a la plataforma. }{\pageref{class_o_s_k_1_1_i_o_1_1_gamepad_state}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_gltf_material_info}{OSK\+::\+ASSETS\+::\+Gltf\+Material\+Info}} \\*Información relevante de un material del modelo GLTF. }{\pageref{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_gltf_material_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_gltf_model_info}{OSK\+::\+ASSETS\+::\+Gltf\+Model\+Info}} \\*Información relevante de un modelo GLTF, necesario para la correcta generación de meshes. }{\pageref{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_gltf_model_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_barrier_info}{OSK\+::\+GRAPHICS\+::\+Gpu\+Barrier\+Info}} }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_barrier_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_buffer_memory_block_info}{OSK\+::\+GRAPHICS\+::\+Gpu\+Buffer\+Memory\+Block\+Info}} }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_buffer_memory_block_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_data_buffer}{OSK\+::\+GRAPHICS\+::\+Gpu\+Data\+Buffer}} \\*Representa un buffer genérico en la GPU. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_data_buffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_dx12}{OSK\+::\+GRAPHICS\+::\+Gpu\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image}{OSK\+::\+GRAPHICS\+::\+Gpu\+Image}} \\*Representación interna de una imagen en la GPU }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_barrier_info}{OSK\+::\+GRAPHICS\+::\+Gpu\+Image\+Barrier\+Info}} }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_barrier_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_dx12}{OSK\+::\+GRAPHICS\+::\+Gpu\+Image\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_sampler_desc}{OSK\+::\+GRAPHICS\+::\+Gpu\+Image\+Sampler\+Desc}} \\*Establece propiedades básicas sobre el acceso a la imagen. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_sampler_desc}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_view_dx12}{OSK\+::\+GRAPHICS\+::\+Gpu\+Image\+View\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_view_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_view_vulkan}{OSK\+::\+GRAPHICS\+::\+Gpu\+Image\+View\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_view_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_vulkan}{OSK\+::\+GRAPHICS\+::\+Gpu\+Image\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_index_buffer_dx12}{OSK\+::\+GRAPHICS\+::\+Gpu\+Index\+Buffer\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_index_buffer_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_index_buffer_vulkan}{OSK\+::\+GRAPHICS\+::\+Gpu\+Index\+Buffer\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_index_buffer_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_allocator_dx12}{OSK\+::\+GRAPHICS\+::\+Gpu\+Memory\+Allocator\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_allocator_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_allocator_vulkan}{OSK\+::\+GRAPHICS\+::\+Gpu\+Memory\+Allocator\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_allocator_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_block_dx12}{OSK\+::\+GRAPHICS\+::\+Gpu\+Memory\+Block\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_block_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_block_vulkan}{OSK\+::\+GRAPHICS\+::\+Gpu\+Memory\+Block\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_block_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_subblock_dx12}{OSK\+::\+GRAPHICS\+::\+Gpu\+Memory\+Subblock\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_subblock_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_subblock_vulkan}{OSK\+::\+GRAPHICS\+::\+Gpu\+Memory\+Subblock\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_memory_subblock_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_storage_buffer_dx12}{OSK\+::\+GRAPHICS\+::\+Gpu\+Storage\+Buffer\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_storage_buffer_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_storage_buffer_vk}{OSK\+::\+GRAPHICS\+::\+Gpu\+Storage\+Buffer\+Vk}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_storage_buffer_vk}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_uniform_buffer_dx12}{OSK\+::\+GRAPHICS\+::\+Gpu\+Uniform\+Buffer\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_uniform_buffer_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_uniform_buffer_vulkan}{OSK\+::\+GRAPHICS\+::\+Gpu\+Uniform\+Buffer\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_uniform_buffer_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vertex_buffer_dx12}{OSK\+::\+GRAPHICS\+::\+Gpu\+Vertex\+Buffer\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vertex_buffer_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vertex_buffer_vulkan}{OSK\+::\+GRAPHICS\+::\+Gpu\+Vertex\+Buffer\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vertex_buffer_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vertex_description_vulkan}{OSK\+::\+GRAPHICS\+::\+Gpu\+Vertex\+Description\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vertex_description_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vulkan}{OSK\+::\+GRAPHICS\+::\+Gpu\+Vulkan}} \\*Implementación de la interfaz para el renderizador de Vulkan. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_graphics_pipeline_dx12}{OSK\+::\+GRAPHICS\+::\+Graphics\+Pipeline\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_graphics_pipeline_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_graphics_pipeline_vulkan}{OSK\+::\+GRAPHICS\+::\+Graphics\+Pipeline\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_graphics_pipeline_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstd_1_1hash_3_01_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_image_view_01_4}{std\+::hash$<$ OSK\+::\+GRAPHICS\+::\+IGpu\+Image\+View $>$}} }{\pageref{structstd_1_1hash_3_01_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_image_view_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstd_1_1hash_3_01_o_s_k_1_1_pair_3_01std_1_1string_00_01std_1_1string_01_4_01_4}{std\+::hash$<$ OSK\+::\+Pair$<$ std\+::string, std\+::string $>$ $>$}} }{\pageref{structstd_1_1hash_3_01_o_s_k_1_1_pair_3_01std_1_1string_00_01std_1_1string_01_4_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_hash_map}{OSK\+::\+Hash\+Map$<$ TKey, TValue, num\+Buckets $>$}} \\*Un \mbox{\hyperlink{class_o_s_k_1_1_hash_map}{Hash\+Map}} representa una colleción que enlaza un valor a otro. Está compuesto internamente por varias colecciones que almacenan los datos }{\pageref{class_o_s_k_1_1_hash_map}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_hlsl_runtime_compiler}{OSK\+::\+GRAPHICS\+::\+Hlsl\+Runtime\+Compiler}} \\*Clase auxiliar que permite compilar shaders HLSL en tiempo de ejecución. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_hlsl_runtime_compiler}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_i_asset}{OSK\+::\+ASSETS\+::\+IAsset}} \\*Un asset es un archivo/contenido que se usa en un juego. Incluye contenido como texturas, modelos 3D, efectos de sonido, música, etc.. }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_i_asset}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_i_asset_loader}{OSK\+::\+ASSETS\+::\+IAsset\+Loader}} \\*Clase que se encarga de cargar un asset de un tipo en concreto }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_i_asset_loader}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_bottom_level_acceleration_structure}{OSK\+::\+GRAPHICS\+::\+IBottom\+Level\+Acceleration\+Structure}} \\*Estructura de aceleración de nivel bajo\+: contiene la geometría de un modelo 3D. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_bottom_level_acceleration_structure}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_command_list}{OSK\+::\+GRAPHICS\+::\+ICommand\+List}} \\*Una lista de comandos contiene una serie de comandos que serán enviados a la GPU para su ejecución }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_command_list}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_command_pool}{OSK\+::\+GRAPHICS\+::\+ICommand\+Pool}} \\*Una pool de comandos se encarga de crear una serie de listas de comandos. Al mismo tiempo, al destruir el pool se destruirán cada una de las listas creadas por el pool. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_command_pool}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_command_queue}{OSK\+::\+GRAPHICS\+::\+ICommand\+Queue}} \\*Una cola de comandos almacena todas las listas de comandos que se envían a la GPU }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_command_queue}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_i_component_container}{OSK\+::\+ECS\+::\+IComponent\+Container}} \\*Clase base para el contenedor de componentes. }{\pageref{class_o_s_k_1_1_e_c_s_1_1_i_component_container}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_compute_pipeline}{OSK\+::\+GRAPHICS\+::\+ICompute\+Pipeline}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_compute_pipeline}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_i_game}{OSK\+::\+IGame}} \\*Esta clase representa la clase principal de un juego de OSKengine. No es estrictamente necesaria para desarrollar con OSKengine, pero es un buen punto de partida. Ofrece una abstracción mínima }{\pageref{class_o_s_k_1_1_i_game}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu}{OSK\+::\+GRAPHICS\+::\+IGpu}} \\*Interfaz de una tarjeta gráfica }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_image_view}{OSK\+::\+GRAPHICS\+::\+IGpu\+Image\+View}} \\*Un image view describe cómo y a qúe parte de una imagen se va a acceder al usarla. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_image_view}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_index_buffer}{OSK\+::\+GRAPHICS\+::\+IGpu\+Index\+Buffer}} \\*Un index buffer contiene los índices para el renderizado de un modelo 2D o 3D. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_index_buffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_memory_allocator}{OSK\+::\+GRAPHICS\+::\+IGpu\+Memory\+Allocator}} \\*El asignador de memoria se encarga de reservar grandes bloques de memoria en la GPU, que después podrán ser usados para almacenar texturas, buffers, etc }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_memory_allocator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_memory_block}{OSK\+::\+GRAPHICS\+::\+IGpu\+Memory\+Block}} \\*Un bloque de memoria representa una región de memoria que ha sidon reservada }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_memory_block}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_memory_subblock}{OSK\+::\+GRAPHICS\+::\+IGpu\+Memory\+Subblock}} \\*Representa una región de memoria dedicada a un único recurso }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_memory_subblock}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_object}{OSK\+::\+GRAPHICS\+::\+IGpu\+Object}} \\*Interfaz común para los objetos almacenados en la CPU. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_object}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_storage_buffer}{OSK\+::\+GRAPHICS\+::\+IGpu\+Storage\+Buffer}} \\*Un buffer que contiene información read-\/write. Equivalente a un UAV buffer en DX12. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_storage_buffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_uniform_buffer}{OSK\+::\+GRAPHICS\+::\+IGpu\+Uniform\+Buffer}} \\*Un uniform buffer contiene información arbitraria a la que se puede acceder a la hora de renderizar. Es read-\/only. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_uniform_buffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_vertex_buffer}{OSK\+::\+GRAPHICS\+::\+IGpu\+Vertex\+Buffer}} \\*Un vertex buffer es un buffer de memoria en la GPU que almacena los vértices de un modelo 3D o un sprite. ~\newline
 }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_vertex_buffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_vertex_description}{OSK\+::\+GRAPHICS\+::\+IGpu\+Vertex\+Description}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_vertex_description}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_graphics_pipeline}{OSK\+::\+GRAPHICS\+::\+IGraphics\+Pipeline}} \\*El graphics pipeline es el encargado de transformar los modelos 3D en una imagen final. Contiene información y ajustes que cambian este proceso de renerizado. Debe usarse con shaders para que funcione. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_graphics_pipeline}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_i_o_1_1_i_input_listener}{OSK\+::\+IO\+::\+IInput\+Listener}} \\*Clase que reacciona a los eventos de entrada }{\pageref{class_o_s_k_1_1_i_o_1_1_i_input_listener}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot}{OSK\+::\+GRAPHICS\+::\+IMaterial\+Slot}} \\*Un slot contiene referencias a los recursos (UNIFORM BUFFER, TEXTURE, etc...) que se envían a la GPU }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_i_mesh_loader}{OSK\+::\+ASSETS\+::\+IMesh\+Loader}} \\*Clase base para poder importar un modelo GLTF. Se debe crear una clase hija por cada tipo de vértice que se quiera cargar }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_i_mesh_loader}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vulkan_1_1_info}{OSK\+::\+GRAPHICS\+::\+Gpu\+Vulkan\+::\+Info}} \\*Información interna de una GPU. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vulkan_1_1_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_i_o_1_1_input_manager}{OSK\+::\+IO\+::\+Input\+Manager}} \\*Maneja los input listeners del juego, llamando a sus funciones cuando sea necesario. }{\pageref{class_o_s_k_1_1_i_o_1_1_input_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_pipeline_dx12}{OSK\+::\+GRAPHICS\+::\+IPipeline\+Dx12}} \\*Clase base para todos los pipelines de DirectX 12. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_pipeline_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_pipeline_layout}{OSK\+::\+GRAPHICS\+::\+IPipeline\+Layout}} \\*Un pipeline layout define el layout del pipeline, es decir\+: define qué recursos necesita para el renderizado (textura, buffers, push constants...) }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_pipeline_layout}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_pipeline_vulkan}{OSK\+::\+GRAPHICS\+::\+IPipeline\+Vulkan}} \\*Clase base para todos los pipelines de Vulkan. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_pipeline_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_post_process_pass}{OSK\+::\+GRAPHICS\+::\+IPost\+Process\+Pass}} \\*Clase base que permite ejecutar pases de efectos de postprocesamiento }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_post_process_pass}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_raytracing_pipeline}{OSK\+::\+GRAPHICS\+::\+IRaytracing\+Pipeline}} \\*Pipeline para el renderizado usando trazado de rayos. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_raytracing_pipeline}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_renderer}{OSK\+::\+GRAPHICS\+::\+IRenderer}} \\*Proporciona la interfaz de un renderizador }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_renderer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_i_render_system}{OSK\+::\+ECS\+::\+IRender\+System}} \\*Clase base para sistemas de renderizado }{\pageref{class_o_s_k_1_1_e_c_s_1_1_i_render_system}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_irradiance_map}{OSK\+::\+ASSETS\+::\+Irradiance\+Map}} \\*Un irradiance map es un cubemap que contiene información sobre el color de la luz procedente de la escena }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_irradiance_map}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_irradiance_map_loader}{OSK\+::\+ASSETS\+::\+Irradiance\+Map\+Loader}} }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_irradiance_map_loader}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_rt_shader_table}{OSK\+::\+GRAPHICS\+::\+IRt\+Shader\+Table}} \\*Tabla que contiene los shaders que pueden ser invocados por un renderizado de trazado de rayos }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_rt_shader_table}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_swapchain}{OSK\+::\+GRAPHICS\+::\+ISwapchain}} \\*Un swapchain es una estructura encargada de manejar el cambio de imagenes que son representadas en el monitor }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_swapchain}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_sync_device}{OSK\+::\+GRAPHICS\+::\+ISync\+Device}} \\*Una estructura que se encarga de sincronizar el renderizador, asegurándose de que se renderiza sobre la imagen correcta del swapchain, y de que no comenzamos a renderizar hasta no tener disponible la siguiente imagen del swapchain }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_sync_device}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_i_system}{OSK\+::\+ECS\+::\+ISystem}} \\*Un sistema se encarga de ejecutar lógica con los datos de los componentes. Los componentes no son más que colecciones de datos\+: la lógica está en los sistemas }{\pageref{class_o_s_k_1_1_e_c_s_1_1_i_system}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_dynamic_array_1_1_iterator}{OSK\+::\+Dynamic\+Array$<$ T $>$\+::\+Iterator}} \\*Clase que representa un elemento de un \mbox{\hyperlink{class_o_s_k_1_1_dynamic_array}{Dynamic\+Array}} }{\pageref{class_o_s_k_1_1_dynamic_array_1_1_iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_hash_map_1_1_iterator}{OSK\+::\+Hash\+Map$<$ TKey, TValue, num\+Buckets $>$\+::\+Iterator}} \\*Un iterador apunta a una pareja de la colección. Se puede recorrer la colección a través de los iteradores }{\pageref{class_o_s_k_1_1_hash_map_1_1_iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_linked_list_1_1_iterator}{OSK\+::\+Linked\+List$<$ T $>$\+::\+Iterator}} \\*Iterador de una linked list. }{\pageref{class_o_s_k_1_1_linked_list_1_1_iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_top_level_acceleration_structure}{OSK\+::\+GRAPHICS\+::\+ITop\+Level\+Acceleration\+Structure}} \\*Estructura de aceleración de nivel alto. Contiene la geometría a renderizar mediante trazado de rayos, la cual estará contenida en las estructuras de nivel bajo \mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_bottom_level_acceleration_structure}{IBottom\+Level\+Acceleration\+Structure}}. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_top_level_acceleration_structure}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_i_o_1_1_keyboard_state}{OSK\+::\+IO\+::\+Keyboard\+State}} \\*Representa el estado del teclado en un instante determinado. Contiene el estado (presionado o suelto) de las teclas. }{\pageref{class_o_s_k_1_1_i_o_1_1_keyboard_state}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_lights_buffer_struct}{OSK\+::\+GRAPHICS\+::\+Lights\+Buffer\+Struct}} \\*Estructura preparada para ser insertada en un storage buffer. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_lights_buffer_struct}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_linked_list}{OSK\+::\+Linked\+List$<$ T $>$}} }{\pageref{class_o_s_k_1_1_linked_list}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_i_o_1_1_logger}{OSK\+::\+IO\+::\+Logger}} \\*Clase que permite enviar mensajes por consola, o por donde se defina su salida }{\pageref{class_o_s_k_1_1_i_o_1_1_logger}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material}{OSK\+::\+GRAPHICS\+::\+Material}} \\*Un material define el comportamiento del renderizador con un objeto en concreto. Debe definirse el layout del material, indicando qué slots (y bindings) serán usados en los shaders }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_instance}{OSK\+::\+GRAPHICS\+::\+Material\+Instance}} \\*Mientras que un \mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material}{Material}} define a grandes rasgos el comportamiento al renderizarse los objetos, un \mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_instance}{Material\+Instance}} permite ajustar el renderizado más finamente, permitiendo asignar qué recursos se envían a los shaders (UNIFORM BUFFER, TEXTURE, etc...). }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_instance}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout}{OSK\+::\+GRAPHICS\+::\+Material\+Layout}} \\*El layout de un material determina qué slots pertenecen a ese material. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout_binding}{OSK\+::\+GRAPHICS\+::\+Material\+Layout\+Binding}} \\*Un binding de un layout }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout_binding}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout_push_constant}{OSK\+::\+GRAPHICS\+::\+Material\+Layout\+Push\+Constant}} \\*Un push constant permite enviar datos a la GPU directamente en la lista de comandos. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout_push_constant}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout_slot}{OSK\+::\+GRAPHICS\+::\+Material\+Layout\+Slot}} \\*Un \mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout_slot}{Material\+Layout\+Slot}} agrupa varios Material\+Layout\+Bindings\+: son una manera de unir bindings que se usen en una frecuencia similar. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout_slot}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12}{OSK\+::\+GRAPHICS\+::\+Material\+Slot\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan}{OSK\+::\+GRAPHICS\+::\+Material\+Slot\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_system}{OSK\+::\+GRAPHICS\+::\+Material\+System}} \\*Clase que se encarga de cargar y manejar los materiales. Un material define el comportamiento del renderizador con un objeto en concreto. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_system}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_mesh3_d}{OSK\+::\+GRAPHICS\+::\+Mesh3D}} \\*Un mesh representa una serie de primitivas (triángulos) de un modelo 3D que comparten unas mismas propiedades de material }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_mesh3_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_mesh_metadata}{OSK\+::\+ASSETS\+::\+Mesh\+Metadata}} \\*Contiene datos necesarios para seguir procesando los meshes. Estos datos se pueden procesar de manera distinta dependiendo del proceso de renderizado implementado. }{\pageref{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_mesh_metadata}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_mesh_node}{OSK\+::\+GRAPHICS\+::\+Mesh\+Node}} \\*Hueso de la animación. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_mesh_node}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_model3_d}{OSK\+::\+ASSETS\+::\+Model3D}} \\*Un modelo 3D, para el renderizado 3D. Está compuesto por una serie de meshes 3D. }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_model3_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_model_component3_d}{OSK\+::\+ECS\+::\+Model\+Component3D}} \\*Componente para el renderizado 3D de un objeto }{\pageref{class_o_s_k_1_1_e_c_s_1_1_model_component3_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_model_loader3_d}{OSK\+::\+ASSETS\+::\+Model\+Loader3D}} }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_model_loader3_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_model_metadata}{OSK\+::\+ASSETS\+::\+Model\+Metadata}} \\*Contiene datos necesarios para seguir procesando el modelo. Estos datos se pueden procesar de manera distinta dependiendo del proceso de renderizado implementado. }{\pageref{struct_o_s_k_1_1_a_s_s_e_t_s_1_1_model_metadata}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_i_o_1_1_mouse_state}{OSK\+::\+IO\+::\+Mouse\+State}} \\*Struct que almacena el estado del ratón en un determinado momento. Contiene la posición, el scroll y el estado de los botones. }{\pageref{class_o_s_k_1_1_i_o_1_1_mouse_state}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_linked_list_1_1_node}{OSK\+::\+Linked\+List$<$ T $>$\+::\+Node}} \\*Un nodo contiene un valor almacenado, y referencias a los nodos anterior y posterior. }{\pageref{class_o_s_k_1_1_linked_list_1_1_node}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_owned_ptr}{OSK\+::\+Owned\+Ptr$<$ T $>$}} \\*Es dueño de un puntero }{\pageref{class_o_s_k_1_1_owned_ptr}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_pair}{OSK\+::\+Pair$<$ T1, T2 $>$}} \\*Pareja con dos elementos. }{\pageref{struct_o_s_k_1_1_pair}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_pbr_deferred_render_system}{OSK\+::\+ECS\+::\+Pbr\+Deferred\+Render\+System}} }{\pageref{class_o_s_k_1_1_e_c_s_1_1_pbr_deferred_render_system}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_pipeline_create_info}{OSK\+::\+GRAPHICS\+::\+Pipeline\+Create\+Info}} \\*Contiene la información necesaria para configurar un nuevo graphics pipeline. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_pipeline_create_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_pipeline_layout_dx12}{OSK\+::\+GRAPHICS\+::\+Pipeline\+Layout\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_pipeline_layout_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_pipeline_layout_vulkan}{OSK\+::\+GRAPHICS\+::\+Pipeline\+Layout\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_pipeline_layout_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_point_light}{OSK\+::\+GRAPHICS\+::\+Point\+Light}} \\*Representa una luz puntual. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_point_light}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_push_const2_d}{OSK\+::\+GRAPHICS\+::\+Push\+Const2D}} \\*Información push constant usada en el sistema de renderizado 2D por defecto. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_push_const2_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_quaternion}{OSK\+::\+Quaternion}} \\*Representa un cuaternión, para representar una orientación. }{\pageref{class_o_s_k_1_1_quaternion}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_queue_family_indices}{OSK\+::\+GRAPHICS\+::\+Queue\+Family\+Indices}} \\*Contiene información sobre qué familias de comandos soporta una GPU. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_queue_family_indices}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_raytracing_pipeline_vulkan}{OSK\+::\+GRAPHICS\+::\+Raytracing\+Pipeline\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_raytracing_pipeline_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_renderer_dx12}{OSK\+::\+GRAPHICS\+::\+Renderer\+Dx12}} \\*Implementación de la interfaz para el renderizador de DirectX 12. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_renderer_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_renderer_vulkan}{OSK\+::\+GRAPHICS\+::\+Renderer\+Vulkan}} \\*Implementación de la interfaz para el renderizador de Vulkan. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_renderer_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_render_pass_image_info}{OSK\+::\+GRAPHICS\+::\+Render\+Pass\+Image\+Info}} }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_render_pass_image_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_render_system2_d}{OSK\+::\+ECS\+::\+Render\+System2D}} }{\pageref{class_o_s_k_1_1_e_c_s_1_1_render_system2_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_render_system3_d}{OSK\+::\+ECS\+::\+Render\+System3D}} \\*Sistema que se encarga del renderizado de modelos 3D de los objetos }{\pageref{class_o_s_k_1_1_e_c_s_1_1_render_system3_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_render_target}{OSK\+::\+GRAPHICS\+::\+Render\+Target}} \\*Representa una textura a la que se puede renderizar }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_render_target}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_memory_block_1_1_reusable_memory_subblock}{OSK\+::\+GRAPHICS\+::\+IGpu\+Memory\+Block\+::\+Reusable\+Memory\+Subblock}} \\*Estructura que se usa cuando un subbloque ya no está en uso\+: una región de memoria entre dos subbloques en uso, pero que puede ser utilizada. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_memory_block_1_1_reusable_memory_subblock}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_rt_shader_table_vulkan}{OSK\+::\+GRAPHICS\+::\+Rt\+Shader\+Table\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_rt_shader_table_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_shader_stage_dx12}{OSK\+::\+GRAPHICS\+::\+Shader\+Stage\+Dx12}} \\*Contiene los datos compilados de un shader. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_shader_stage_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_shader_stage_vulkan}{OSK\+::\+GRAPHICS\+::\+Shader\+Stage\+Vulkan}} \\*Contiene los datos compilados de un shader. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_shader_stage_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_shadow_map}{OSK\+::\+GRAPHICS\+::\+Shadow\+Map}} \\*Renderiza un mapa de profundidad de la escena desde el punto de vista de una luz direccional }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_shadow_map}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_shared_ptr}{Shared\+Ptr$<$ T $>$}} \\*Contiene un puntero al que pueden hacer referencia varios \mbox{\hyperlink{class_shared_ptr}{Shared\+Ptr}}. Si el último \mbox{\hyperlink{class_shared_ptr}{Shared\+Ptr}} que hace referencia a un puntero es desstruido, el puntero será eliminado }{\pageref{class_shared_ptr}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_skybox_render_system}{OSK\+::\+ECS\+::\+Skybox\+Render\+System}} }{\pageref{class_o_s_k_1_1_e_c_s_1_1_skybox_render_system}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_smaa_pass}{OSK\+::\+GRAPHICS\+::\+Smaa\+Pass}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_smaa_pass}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_spirv_to_hlsl}{OSK\+::\+GRAPHICS\+::\+Spirv\+To\+Hlsl}} \\*Clase auxiliar que genera código HLSL a partir de código SPIR-\/V, usando spirv\+\_\+cross. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_spirv_to_hlsl}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_sprite}{OSK\+::\+GRAPHICS\+::\+Sprite}} \\*Representa un sprite\+: una textura que puede ser renderizada. También es un componente que permite a un Game\+Object tener un sprite asociado }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_sprite}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_sprite_renderer}{OSK\+::\+GRAPHICS\+::\+Sprite\+Renderer}} \\*Clase que simplifica el proceso de renderizado de imágenes 2D sin tener que usar el sistema Render\+System2D, lo cual te da un mayor control sobre el orden en el que se renderizan los sprites }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_sprite_renderer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_static_mesh_loader}{OSK\+::\+ASSETS\+::\+Static\+Mesh\+Loader}} }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_static_mesh_loader}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_swapchain_dx12}{OSK\+::\+GRAPHICS\+::\+Swapchain\+Dx12}} \\*Un swapchain es una estructura encargada de manejar el cambio de imagenes que son representadas en el monitor }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_swapchain_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vulkan_1_1_info_1_1_swapchain_support_details}{OSK\+::\+GRAPHICS\+::\+Gpu\+Vulkan\+::\+Info\+::\+Swapchain\+Support\+Details}} \\*Detalles sobre el soporte de swapchain de una GPU. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_vulkan_1_1_info_1_1_swapchain_support_details}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_swapchain_vulkan}{OSK\+::\+GRAPHICS\+::\+Swapchain\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_swapchain_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_sync_device_dx12}{OSK\+::\+GRAPHICS\+::\+Sync\+Device\+Dx12}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_sync_device_dx12}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_sync_device_vulkan}{OSK\+::\+GRAPHICS\+::\+Sync\+Device\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_sync_device_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_system_manager}{OSK\+::\+ECS\+::\+System\+Manager}} \\*El \mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_system_manager}{System\+Manager}} se encarga de almacenar y manejar los sistemas del juego. Es el encargado de llamar a las funciones On\+Tick de los sistemas, además de introducir y eliminar de los sistemas a los Game\+Objects que cada sistema vaya a procesar }{\pageref{class_o_s_k_1_1_e_c_s_1_1_system_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_e_c_s_1_1_terrain_component}{OSK\+::\+ECS\+::\+Terrain\+Component}} \\*Componente que se puede usar para renderizar un terreno. El terreno debe haber sido antes generado }{\pageref{struct_o_s_k_1_1_e_c_s_1_1_terrain_component}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_terrain_render_system}{OSK\+::\+ECS\+::\+Terrain\+Render\+System}} }{\pageref{class_o_s_k_1_1_e_c_s_1_1_terrain_render_system}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_texture}{OSK\+::\+ASSETS\+::\+Texture}} \\*Una textura que será usada en renderizado 2D / 3D. }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_texture}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_texture_coordinates2_d}{OSK\+::\+GRAPHICS\+::\+Texture\+Coordinates2D}} \\*Contiene las coordenadas de texturas y el tipo que son (normalizadas o por píxeles. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_texture_coordinates2_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_a_s_s_e_t_s_1_1_texture_loader}{OSK\+::\+ASSETS\+::\+Texture\+Loader}} }{\pageref{class_o_s_k_1_1_a_s_s_e_t_s_1_1_texture_loader}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_tone_mapping_pass}{OSK\+::\+GRAPHICS\+::\+Tone\+Mapping\+Pass}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_tone_mapping_pass}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_top_level_acceleration_structure_vulkan}{OSK\+::\+GRAPHICS\+::\+Top\+Level\+Acceleration\+Structure\+Vulkan}} }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_top_level_acceleration_structure_vulkan}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_transform2_d}{OSK\+::\+ECS\+::\+Transform2D}} \\*Clase que almacena el \textquotesingle{}transform\textquotesingle{} de un objeto en un mundo 2D. El transform contiene posición, escala y rotación. A este transform se pueden enlazar otros transform ahijados, de tal manera que al cambiar el transform padre, el resto de transforms también ven sus variables cambiadas. }{\pageref{class_o_s_k_1_1_e_c_s_1_1_transform2_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_e_c_s_1_1_transform3_d}{OSK\+::\+ECS\+::\+Transform3D}} }{\pageref{class_o_s_k_1_1_e_c_s_1_1_transform3_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_u_i_1_1_ui_element}{OSK\+::\+UI\+::\+Ui\+Element}} \\*Elemento base de una interfaz de usuario. }{\pageref{class_o_s_k_1_1_u_i_1_1_ui_element}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_u_i_1_1_ui_renderer}{OSK\+::\+UI\+::\+Ui\+Renderer}} \\*Clase que ayuda a renderizar una interfaz de usuario. }{\pageref{class_o_s_k_1_1_u_i_1_1_ui_renderer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_unique_ptr}{OSK\+::\+Unique\+Ptr$<$ T $>$}} \\*Es dueño de un puntero. El puntero original es eliminado al destruirse el \mbox{\hyperlink{class_o_s_k_1_1_unique_ptr}{Unique\+Ptr}} }{\pageref{class_o_s_k_1_1_unique_ptr}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_unique_ptr_3_01_t_0f_0e_4}{OSK\+::\+Unique\+Ptr$<$ T\mbox{[}$\,$\mbox{]}$>$}} \\*Es dueño de un puntero. El puntero original es eliminado al destruirse el \mbox{\hyperlink{class_o_s_k_1_1_unique_ptr}{Unique\+Ptr}}. }{\pageref{class_o_s_k_1_1_unique_ptr_3_01_t_0f_0e_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_vector2__t}{OSK\+::\+Vector2\+\_\+t$<$ T $>$}} \\*Representa un vector 2D. }{\pageref{class_o_s_k_1_1_vector2__t}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_vector3__t}{OSK\+::\+Vector3\+\_\+t$<$ T $>$}} \\*Representa un vector 3D. }{\pageref{class_o_s_k_1_1_vector3__t}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_vector4__t}{OSK\+::\+Vector4\+\_\+t$<$ T $>$}} \\*Representa un vector con 4 coordenadas (Rectangle). }{\pageref{class_o_s_k_1_1_vector4__t}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_version}{OSK\+::\+Version}} \\*Representa una versión. }{\pageref{struct_o_s_k_1_1_version}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_vertex2_d}{OSK\+::\+GRAPHICS\+::\+Vertex2D}} }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_vertex2_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_vertex3_d}{OSK\+::\+GRAPHICS\+::\+Vertex3D}} }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_vertex3_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_vertex_anim3_d}{OSK\+::\+GRAPHICS\+::\+Vertex\+Anim3D}} }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_vertex_anim3_d}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_vertex_info}{OSK\+::\+GRAPHICS\+::\+Vertex\+Info}} \\*Información de los atributos de un vértice. El graphics pipeline lo usará para configurar el tipo de vértice deseado. }{\pageref{class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_vertex_info}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_viewport}{OSK\+::\+GRAPHICS\+::\+Viewport}} \\*El viewport define que área de la textura final será renderizada. }{\pageref{struct_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_viewport}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_o_s_k_1_1_i_o_1_1_window}{OSK\+::\+IO\+::\+Window}} \\*Clase que representa una ventana. En esta ventana se renderizará el juego. También se encarga del input mediante teclado, ratón, mando, etc.. }{\pageref{class_o_s_k_1_1_i_o_1_1_window}}{}
\end{DoxyCompactList}
