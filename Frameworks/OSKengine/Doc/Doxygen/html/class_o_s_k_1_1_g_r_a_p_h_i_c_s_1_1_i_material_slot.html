<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OSKengine: Referencia de la Clase OSK::GRAPHICS::IMaterialSlot</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="awesome-css.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="card_low.png"/></td>
  <td id="projectalign">
   <div id="projectname">OSKengine<span id="projectnumber">&#160;Indev</span>
   </div>
   <div id="projectbrief">Motor de videojuegos.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Buscar','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Buscar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Métodos públicos</a> &#124;
<a href="#pro-methods">Métodos protegidos</a> &#124;
<a href="#pro-attribs">Atributos protegidos</a> &#124;
<a href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot-members.html">Lista de todos los miembros</a>  </div>
  <div class="headertitle"><div class="title">Referencia de la Clase OSK::GRAPHICS::IMaterialSlot<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_i_material_slot_8h_source.html">IMaterialSlot.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Métodos públicos</h2></td></tr>
<tr class="memitem:a49409314a65d27a7043557d85626cb8b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a49409314a65d27a7043557d85626cb8b">~IMaterialSlot</a> ()=default</td></tr>
<tr class="separator:a49409314a65d27a7043557d85626cb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d37e6bc927e323f076e07508455f28"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires std::is_base_of_v&lt;<a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html">IMaterialSlot</a>, T&gt;</td></tr>
<tr class="memitem:af2d37e6bc927e323f076e07508455f28"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#af2d37e6bc927e323f076e07508455f28">As</a> () const</td></tr>
<tr class="separator:af2d37e6bc927e323f076e07508455f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5f7ce083cf1d96b5eedf0d68ee870e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a7c5f7ce083cf1d96b5eedf0d68ee870e">SetUniformBuffer</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_uniform_buffer.html">IGpuUniformBuffer</a> *buffer)=0</td></tr>
<tr class="separator:a7c5f7ce083cf1d96b5eedf0d68ee870e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e51bf654ce78b7cce5e27a07fb4f1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a02e51bf654ce78b7cce5e27a07fb4f1a">SetUniformBuffers</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_uniform_buffer.html">IGpuUniformBuffer</a> *buffers[<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a2790b1bb1dbf382ccd86a228f9f2ccbd">NUM_RESOURCES_IN_FLIGHT</a>])=0</td></tr>
<tr class="separator:a02e51bf654ce78b7cce5e27a07fb4f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e515a4922e8e2230646cd4bcacf157"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#ab6e515a4922e8e2230646cd4bcacf157">SetTexture</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_a_s_s_e_t_s_1_1_texture.html">ASSETS::Texture</a> *texture, <a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9d">SampledChannel</a> channel=<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9da04bd834032febb3fda8c6936ee140949">SampledChannel::COLOR</a>)</td></tr>
<tr class="separator:ab6e515a4922e8e2230646cd4bcacf157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7836df224731b5288824c3ec064f773f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a7836df224731b5288824c3ec064f773f">SetTextures</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_a_s_s_e_t_s_1_1_texture.html">ASSETS::Texture</a> *texture[<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a2790b1bb1dbf382ccd86a228f9f2ccbd">NUM_RESOURCES_IN_FLIGHT</a>], <a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9d">SampledChannel</a> channel=<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9da04bd834032febb3fda8c6936ee140949">SampledChannel::COLOR</a>)</td></tr>
<tr class="separator:a7836df224731b5288824c3ec064f773f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2359e7cd0c026983bce50b75c96f8b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a5e2359e7cd0c026983bce50b75c96f8b">SetGpuImage</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image.html">GpuImage</a> *image, <a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9d">SampledChannel</a> channel=<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9da04bd834032febb3fda8c6936ee140949">SampledChannel::COLOR</a>, <a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39">SampledArrayType</a> arrayType=<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39a827be7f5269fdb21e2fb90ab4f60e785">SampledArrayType::SINGLE_LAYER</a>, <a class="el" href="_o_s_kmacros_8h.html#a1acaf9dff8b00604e55d38b35a744a9a">TSize</a> arrayLevel=0)=0</td></tr>
<tr class="separator:a5e2359e7cd0c026983bce50b75c96f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697cdef3d31ed21fde3b92a3732fbd6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a697cdef3d31ed21fde3b92a3732fbd6c">SetGpuImages</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image.html">GpuImage</a> *images[<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a2790b1bb1dbf382ccd86a228f9f2ccbd">NUM_RESOURCES_IN_FLIGHT</a>], <a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9d">SampledChannel</a> channel=<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9da04bd834032febb3fda8c6936ee140949">SampledChannel::COLOR</a>, <a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39">SampledArrayType</a> arrayType=<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39a827be7f5269fdb21e2fb90ab4f60e785">SampledArrayType::SINGLE_LAYER</a>, <a class="el" href="_o_s_kmacros_8h.html#a1acaf9dff8b00604e55d38b35a744a9a">TSize</a> arrayLevel=0)=0</td></tr>
<tr class="separator:a697cdef3d31ed21fde3b92a3732fbd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655f5c3de1170cd5f93242577db1a3db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a655f5c3de1170cd5f93242577db1a3db">SetStorageBuffer</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_data_buffer.html">GpuDataBuffer</a> *buffer)=0</td></tr>
<tr class="separator:a655f5c3de1170cd5f93242577db1a3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae088fb79ea614823d3e137d49e079304"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#ae088fb79ea614823d3e137d49e079304">SetStorageBuffers</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_data_buffer.html">GpuDataBuffer</a> *buffers[<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a2790b1bb1dbf382ccd86a228f9f2ccbd">NUM_RESOURCES_IN_FLIGHT</a>])=0</td></tr>
<tr class="separator:ae088fb79ea614823d3e137d49e079304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44593d8fec98014804bc7c979171fac6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a44593d8fec98014804bc7c979171fac6">SetStorageImage</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image.html">GpuImage</a> *image, <a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39">SampledArrayType</a> arrayType=<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39a827be7f5269fdb21e2fb90ab4f60e785">SampledArrayType::SINGLE_LAYER</a>, <a class="el" href="_o_s_kmacros_8h.html#a1acaf9dff8b00604e55d38b35a744a9a">TSize</a> arrayLayer=0)=0</td></tr>
<tr class="separator:a44593d8fec98014804bc7c979171fac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade20b6caf66addc900d9a36b34742801"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#ade20b6caf66addc900d9a36b34742801">SetStorageImages</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image.html">GpuImage</a> *images[<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a2790b1bb1dbf382ccd86a228f9f2ccbd">NUM_RESOURCES_IN_FLIGHT</a>], <a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39">SampledArrayType</a> arrayType=<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39a827be7f5269fdb21e2fb90ab4f60e785">SampledArrayType::SINGLE_LAYER</a>, <a class="el" href="_o_s_kmacros_8h.html#a1acaf9dff8b00604e55d38b35a744a9a">TSize</a> arrayLayer=0)=0</td></tr>
<tr class="separator:ade20b6caf66addc900d9a36b34742801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa528e548afe9c55625777b5be06db7f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#aa528e548afe9c55625777b5be06db7f9">SetAccelerationStructure</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> *accelerationStructure)=0</td></tr>
<tr class="separator:aa528e548afe9c55625777b5be06db7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fac55ce6d7b7c2826678bba4cdcec5d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a7fac55ce6d7b7c2826678bba4cdcec5d">SetAccelerationStructures</a> (const std::string &amp;binding, const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> *accelerationStructure[<a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a2790b1bb1dbf382ccd86a228f9f2ccbd">NUM_RESOURCES_IN_FLIGHT</a>])=0</td></tr>
<tr class="separator:a7fac55ce6d7b7c2826678bba4cdcec5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d6977bf0f937b5086a32ca8af9d3b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3">FlushUpdate</a> ()=0</td></tr>
<tr class="separator:a71d6977bf0f937b5086a32ca8af9d3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1aa678ef234df2f183df6778df24ec1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#ad1aa678ef234df2f183df6778df24ec1">GetName</a> () const</td></tr>
<tr class="separator:ad1aa678ef234df2f183df6778df24ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Métodos protegidos</h2></td></tr>
<tr class="memitem:adbb0631957189108acba37897877c3a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#adbb0631957189108acba37897877c3a3">IMaterialSlot</a> (const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout.html">MaterialLayout</a> *<a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a0edfe4cc881bcaf3507b9d5ce345102a">layout</a>, const std::string &amp;<a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a92532b4b6b8a32041dbacf144af8340f">name</a>)</td></tr>
<tr class="separator:adbb0631957189108acba37897877c3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Atributos protegidos</h2></td></tr>
<tr class="memitem:a0edfe4cc881bcaf3507b9d5ce345102a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout.html">MaterialLayout</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a0edfe4cc881bcaf3507b9d5ce345102a">layout</a> = nullptr</td></tr>
<tr class="separator:a0edfe4cc881bcaf3507b9d5ce345102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92532b4b6b8a32041dbacf144af8340f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a92532b4b6b8a32041dbacf144af8340f">name</a></td></tr>
<tr class="separator:a92532b4b6b8a32041dbacf144af8340f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descripción detallada</h2>
<div class="textblock"><p >Un slot contiene referencias a los recursos (UNIFORM BUFFER, TEXTURE, etc...) que se envían a la GPU. </p>
<dl class="section warning"><dt>Atención</dt><dd>Establecer los recursos mediante Set&lt;...&gt; no actualizará los recursos que realmente se enviarán a los shaders, debe llamarse explícitamente a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p class="definition">Definición en la línea <a class="el" href="_i_material_slot_8h_source.html#l00028">28</a> del archivo <a class="el" href="_i_material_slot_8h_source.html">IMaterialSlot.h</a>.</p>
</div><h2 class="groupheader">Documentación del constructor y destructor</h2>
<a id="a49409314a65d27a7043557d85626cb8b" name="a49409314a65d27a7043557d85626cb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49409314a65d27a7043557d85626cb8b">&#9670;&nbsp;</a></span>~IMaterialSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSK::GRAPHICS::IMaterialSlot::~IMaterialSlot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbb0631957189108acba37897877c3a3" name="adbb0631957189108acba37897877c3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb0631957189108acba37897877c3a3">&#9670;&nbsp;</a></span>IMaterialSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IMaterialSlot::IMaterialSlot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout.html">MaterialLayout</a> *&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="_i_material_slot_8cpp_source.html#l00008">8</a> del archivo <a class="el" href="_i_material_slot_8cpp_source.html">IMaterialSlot.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Documentación de las funciones miembro</h2>
<a id="af2d37e6bc927e323f076e07508455f28" name="af2d37e6bc927e323f076e07508455f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d37e6bc927e323f076e07508455f28">&#9670;&nbsp;</a></span>As()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires std::is_base_of_v&lt;<a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html">IMaterialSlot</a>, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * OSK::GRAPHICS::IMaterialSlot::As </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="_i_material_slot_8h_source.html#l00034">34</a> del archivo <a class="el" href="_i_material_slot_8h_source.html">IMaterialSlot.h</a>.</p>

</div>
</div>
<a id="a71d6977bf0f937b5086a32ca8af9d3b3" name="a71d6977bf0f937b5086a32ca8af9d3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d6977bf0f937b5086a32ca8af9d3b3">&#9670;&nbsp;</a></span>FlushUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::FlushUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actualiza los recursos que se enviarán a los shaders. </p>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#a2d0538215f4de0ccf727cf26d96a2432">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#a355547aa767341b813007c2f31cedff4">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<a id="ad1aa678ef234df2f183df6778df24ec1" name="ad1aa678ef234df2f183df6778df24ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1aa678ef234df2f183df6778df24ec1">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string IMaterialSlot::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="_i_material_slot_8cpp_source.html#l00025">25</a> del archivo <a class="el" href="_i_material_slot_8cpp_source.html">IMaterialSlot.cpp</a>.</p>

</div>
</div>
<a id="aa528e548afe9c55625777b5be06db7f9" name="aa528e548afe9c55625777b5be06db7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa528e548afe9c55625777b5be06db7f9">&#9670;&nbsp;</a></span>SetAccelerationStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::SetAccelerationStructure </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> *&#160;</td>
          <td class="paramname"><em>accelerationStructure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece la estructura de aceleración para trazado de rayos que será asignado al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#a2b12e68de248773c807fa37e0d26d28d">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#adf2cd436e9ac955b961143d8e6791622">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<a id="a7fac55ce6d7b7c2826678bba4cdcec5d" name="a7fac55ce6d7b7c2826678bba4cdcec5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fac55ce6d7b7c2826678bba4cdcec5d">&#9670;&nbsp;</a></span>SetAccelerationStructures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::SetAccelerationStructures </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> *&#160;</td>
          <td class="paramname"><em>accelerationStructure</em>[NUM_RESOURCES_IN_FLIGHT]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece la estructura de aceleración para trazado de rayos que será asignado al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Nombre del binding al que se asignará la imagen.</td></tr>
    <tr><td class="paramname">accelerationStructure</td><td>Estructuras de aceleración.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Nota</dt><dd>Habrá una estructura de aceleración por cada frame in flight. </dd></dl>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#a052c4382cf9aa4c7d87e57ce5e8afd43">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#ae431f0a1d0f544c716679c2b87118615">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<a id="a5e2359e7cd0c026983bce50b75c96f8b" name="a5e2359e7cd0c026983bce50b75c96f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2359e7cd0c026983bce50b75c96f8b">&#9670;&nbsp;</a></span>SetGpuImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::SetGpuImage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image.html">GpuImage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9d">SampledChannel</a>&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9da04bd834032febb3fda8c6936ee140949">SampledChannel::COLOR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39">SampledArrayType</a>&#160;</td>
          <td class="paramname"><em>arrayType</em> = <code><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39a827be7f5269fdb21e2fb90ab4f60e785">SampledArrayType::SINGLE_LAYER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_o_s_kmacros_8h.html#a1acaf9dff8b00604e55d38b35a744a9a">TSize</a>&#160;</td>
          <td class="paramname"><em>arrayLevel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece la imagen que será asignada al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Nombre del binding al que se asignará la imagen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#aa4ebea0c5ff02401a6a4680f573f59b3">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#a8c7ef64a401c842f21ecd0225eec740f">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<a id="a697cdef3d31ed21fde3b92a3732fbd6c" name="a697cdef3d31ed21fde3b92a3732fbd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697cdef3d31ed21fde3b92a3732fbd6c">&#9670;&nbsp;</a></span>SetGpuImages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::SetGpuImages </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image.html">GpuImage</a> *&#160;</td>
          <td class="paramname"><em>images</em>[NUM_RESOURCES_IN_FLIGHT], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9d">SampledChannel</a>&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9da04bd834032febb3fda8c6936ee140949">SampledChannel::COLOR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39">SampledArrayType</a>&#160;</td>
          <td class="paramname"><em>arrayType</em> = <code><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39a827be7f5269fdb21e2fb90ab4f60e785">SampledArrayType::SINGLE_LAYER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_o_s_kmacros_8h.html#a1acaf9dff8b00604e55d38b35a744a9a">TSize</a>&#160;</td>
          <td class="paramname"><em>arrayLevel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece la imagen que será asignada al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Nombre del binding al que se asignará la imagen.</td></tr>
    <tr><td class="paramname">images</td><td>Imágenes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Nota</dt><dd>Habrá una imagen por cada frame in flight. </dd></dl>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#a77630b23f85cc8e6d2fd74e014be8679">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#ad28aacbfece8fd6c31c034259569e582">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<a id="a655f5c3de1170cd5f93242577db1a3db" name="a655f5c3de1170cd5f93242577db1a3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655f5c3de1170cd5f93242577db1a3db">&#9670;&nbsp;</a></span>SetStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::SetStorageBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_data_buffer.html">GpuDataBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece el buffer que será usado como storage buffer asignado al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#ad3b8a71b471d369a0c9ffbc06beeabbb">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#ae0dca0f23011328b4d8bd37e49dbe1a6">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<a id="ae088fb79ea614823d3e137d49e079304" name="ae088fb79ea614823d3e137d49e079304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae088fb79ea614823d3e137d49e079304">&#9670;&nbsp;</a></span>SetStorageBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::SetStorageBuffers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_data_buffer.html">GpuDataBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>[NUM_RESOURCES_IN_FLIGHT]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece el buffer que será usado como storage buffer asignado al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Nombre del binding al que se asignará el buffer.</td></tr>
    <tr><td class="paramname">buffers</td><td>Buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Nota</dt><dd>Habrá un buffer por cada frame in flight. </dd></dl>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#ad07dd9b26df5252e06fb1d0d30945e8c">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#aa31aa53881f2da91a1b1df04543ee5b3">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<a id="a44593d8fec98014804bc7c979171fac6" name="a44593d8fec98014804bc7c979171fac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44593d8fec98014804bc7c979171fac6">&#9670;&nbsp;</a></span>SetStorageImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::SetStorageImage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image.html">GpuImage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39">SampledArrayType</a>&#160;</td>
          <td class="paramname"><em>arrayType</em> = <code><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39a827be7f5269fdb21e2fb90ab4f60e785">SampledArrayType::SINGLE_LAYER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_o_s_kmacros_8h.html#a1acaf9dff8b00604e55d38b35a744a9a">TSize</a>&#160;</td>
          <td class="paramname"><em>arrayLayer</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece la imagen que será usada como storage image asignada al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#a75d8e9121b7d0b49b5adae2b716ea2b6">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#aaaef1aa6caecae39001d9c63423339d4">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<a id="ade20b6caf66addc900d9a36b34742801" name="ade20b6caf66addc900d9a36b34742801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade20b6caf66addc900d9a36b34742801">&#9670;&nbsp;</a></span>SetStorageImages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::SetStorageImages </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_gpu_image.html">GpuImage</a> *&#160;</td>
          <td class="paramname"><em>images</em>[NUM_RESOURCES_IN_FLIGHT], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39">SampledArrayType</a>&#160;</td>
          <td class="paramname"><em>arrayType</em> = <code><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a55e114ba828198c2146f5233e462ba39a827be7f5269fdb21e2fb90ab4f60e785">SampledArrayType::SINGLE_LAYER</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_o_s_kmacros_8h.html#a1acaf9dff8b00604e55d38b35a744a9a">TSize</a>&#160;</td>
          <td class="paramname"><em>arrayLayer</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece la imagen que será usada como storage image asignada al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Nombre del binding al que se asignará la imagen.</td></tr>
    <tr><td class="paramname">images</td><td>Imágenes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Nota</dt><dd>Habrá una imagen por cada frame in flight. </dd></dl>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#a144eae4aea0043754be2f6cec96e73a1">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#a5ae3ceb9b6973ab57ceeb2b3429d297e">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<a id="ab6e515a4922e8e2230646cd4bcacf157" name="ab6e515a4922e8e2230646cd4bcacf157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e515a4922e8e2230646cd4bcacf157">&#9670;&nbsp;</a></span>SetTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMaterialSlot::SetTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_a_s_s_e_t_s_1_1_texture.html">ASSETS::Texture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9d">SampledChannel</a>&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9da04bd834032febb3fda8c6936ee140949">SampledChannel::COLOR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establece la textura que será asignada al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Nombre del binding al que se asignará la textura.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p class="definition">Definición en la línea <a class="el" href="_i_material_slot_8cpp_source.html#l00013">13</a> del archivo <a class="el" href="_i_material_slot_8cpp_source.html">IMaterialSlot.cpp</a>.</p>

</div>
</div>
<a id="a7836df224731b5288824c3ec064f773f" name="a7836df224731b5288824c3ec064f773f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7836df224731b5288824c3ec064f773f">&#9670;&nbsp;</a></span>SetTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMaterialSlot::SetTextures </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_a_s_s_e_t_s_1_1_texture.html">ASSETS::Texture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>[NUM_RESOURCES_IN_FLIGHT], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9d">SampledChannel</a>&#160;</td>
          <td class="paramname"><em>channel</em> = <code><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html#a02ed44392ae1f51786ead8911c3afe9da04bd834032febb3fda8c6936ee140949">SampledChannel::COLOR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establece las texturas que serán asignadas al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Nombre del binding al que se asignará la textura.</td></tr>
    <tr><td class="paramname">texture</td><td>Texturas.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Nota</dt><dd>Habrá una textura por cada frame in flight. </dd></dl>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p class="definition">Definición en la línea <a class="el" href="_i_material_slot_8cpp_source.html#l00017">17</a> del archivo <a class="el" href="_i_material_slot_8cpp_source.html">IMaterialSlot.cpp</a>.</p>

</div>
</div>
<a id="a7c5f7ce083cf1d96b5eedf0d68ee870e" name="a7c5f7ce083cf1d96b5eedf0d68ee870e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5f7ce083cf1d96b5eedf0d68ee870e">&#9670;&nbsp;</a></span>SetUniformBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::SetUniformBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_uniform_buffer.html">IGpuUniformBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece el UNIFORM BUFFER que será asignado al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Nombre del binding al que se asignará el UNIFORM BUFFER.</td></tr>
  </table>
  </dd>
</dl>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#a92fd8a49ea158103e4c482e0594842a8">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#a00b39c8aa8e563a5d0776edbf06cbd60">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<a id="a02e51bf654ce78b7cce5e27a07fb4f1a" name="a02e51bf654ce78b7cce5e27a07fb4f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e51bf654ce78b7cce5e27a07fb4f1a">&#9670;&nbsp;</a></span>SetUniformBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OSK::GRAPHICS::IMaterialSlot::SetUniformBuffers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_gpu_uniform_buffer.html">IGpuUniformBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>[NUM_RESOURCES_IN_FLIGHT]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece el UNIFORM BUFFER que será asignado al binding con el nombre dado. Puede usarse esta función para alternar el recurso que está asignado al binding. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Nombre del binding al que se asignará el UNIFORM BUFFER.</td></tr>
    <tr><td class="paramname">buffers</td><td>Uniform buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Nota</dt><dd>Habrá un uniform buffer por cada frame in flight. </dd></dl>
<dl class="section warning"><dt>Atención</dt><dd>No actualizará el recurso que realmente se usará en el shader, se debe llamar a <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html#a71d6977bf0f937b5086a32ca8af9d3b3" title="Actualiza los recursos que se enviarán a los shaders.">FlushUpdate()</a>. </dd></dl>

<p>Implementado en <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_dx12.html#a482811c1c07bb45cf95cdae7b8961f6e">OSK::GRAPHICS::MaterialSlotDx12</a> y <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_slot_vulkan.html#abfbf756343f0c7e5fe8838f4f31cc677">OSK::GRAPHICS::MaterialSlotVulkan</a>.</p>

</div>
</div>
<h2 class="groupheader">Documentación de los datos miembro</h2>
<a id="a0edfe4cc881bcaf3507b9d5ce345102a" name="a0edfe4cc881bcaf3507b9d5ce345102a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edfe4cc881bcaf3507b9d5ce345102a">&#9670;&nbsp;</a></span>layout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_material_layout.html">MaterialLayout</a>* OSK::GRAPHICS::IMaterialSlot::layout = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="_i_material_slot_8h_source.html#l00171">171</a> del archivo <a class="el" href="_i_material_slot_8h_source.html">IMaterialSlot.h</a>.</p>

</div>
</div>
<a id="a92532b4b6b8a32041dbacf144af8340f" name="a92532b4b6b8a32041dbacf144af8340f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92532b4b6b8a32041dbacf144af8340f">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string OSK::GRAPHICS::IMaterialSlot::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definición en la línea <a class="el" href="_i_material_slot_8h_source.html#l00172">172</a> del archivo <a class="el" href="_i_material_slot_8h_source.html">IMaterialSlot.h</a>.</p>

</div>
</div>
<hr/>La documentación para esta clase fue generada a partir de los siguientes ficheros:<ul>
<li>OSKengine2/<a class="el" href="_i_material_slot_8h_source.html">IMaterialSlot.h</a></li>
<li>OSKengine2/<a class="el" href="_i_material_slot_8cpp_source.html">IMaterialSlot.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_o_s_k.html">OSK</a></li><li class="navelem"><a class="el" href="namespace_o_s_k_1_1_g_r_a_p_h_i_c_s.html">GRAPHICS</a></li><li class="navelem"><a class="el" href="class_o_s_k_1_1_g_r_a_p_h_i_c_s_1_1_i_material_slot.html">IMaterialSlot</a></li>
    <li class="footer">Generado el Sábado, 15 de Octubre de 2022 00:57:46 para OSKengine por <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
