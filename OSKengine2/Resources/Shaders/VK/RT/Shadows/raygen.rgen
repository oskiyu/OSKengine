#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require

layout (set = 0, binding = 0) uniform accelerationStructureEXT topLevelAccelerationStructure;

layout (set = 1, binding = 0) uniform sampler2D gBufferPosition;
layout (set = 1, binding = 1, rgba8) uniform image2D shadowsImage;
layout (set = 1, binding = 3) uniform sampler2D noiseImage;

struct RayResult {
    bool isInShadows;
    float distance;
};

layout (location = 0) rayPayloadEXT RayResult rayResult;

layout (set = 1, binding = 2) uniform DirectionalLight {
    vec4 directionAndIntensity;
    vec4 color;
} dirLight;

layout (push_constant) uniform Info {
    int frameIndex;
} frameInfo;

const vec2 BlueNoiseInDisk[64] = vec2[64](
    vec2(0.478712,0.875764),
    vec2(-0.337956,-0.793959),
    vec2(-0.955259,-0.028164),
    vec2(0.864527,0.325689),
    vec2(0.209342,-0.395657),
    vec2(-0.106779,0.672585),
    vec2(0.156213,0.235113),
    vec2(-0.413644,-0.082856),
    vec2(-0.415667,0.323909),
    vec2(0.141896,-0.939980),
    vec2(0.954932,-0.182516),
    vec2(-0.766184,0.410799),
    vec2(-0.434912,-0.458845),
    vec2(0.415242,-0.078724),
    vec2(0.728335,-0.491777),
    vec2(-0.058086,-0.066401),
    vec2(0.202990,0.686837),
    vec2(-0.808362,-0.556402),
    vec2(0.507386,-0.640839),
    vec2(-0.723494,-0.229240),
    vec2(0.489740,0.317826),
    vec2(-0.622663,0.765301),
    vec2(-0.010640,0.929347),
    vec2(0.663146,0.647618),
    vec2(-0.096674,-0.413835),
    vec2(0.525945,-0.321063),
    vec2(-0.122533,0.366019),
    vec2(0.195235,-0.687983),
    vec2(-0.563203,0.098748),
    vec2(0.418563,0.561335),
    vec2(-0.378595,0.800367),
    vec2(0.826922,0.001024),
    vec2(-0.085372,-0.766651),
    vec2(-0.921920,0.183673),
    vec2(-0.590008,-0.721799),
    vec2(0.167751,-0.164393),
    vec2(0.032961,-0.562530),
    vec2(0.632900,-0.107059),
    vec2(-0.464080,0.569669),
    vec2(-0.173676,-0.958758),
    vec2(-0.242648,-0.234303),
    vec2(-0.275362,0.157163),
    vec2(0.382295,-0.795131),
    vec2(0.562955,0.115562),
    vec2(0.190586,0.470121),
    vec2(0.770764,-0.297576),
    vec2(0.237281,0.931050),
    vec2(-0.666642,-0.455871),
    vec2(-0.905649,-0.298379),
    vec2(0.339520,0.157829),
    vec2(0.701438,-0.704100),
    vec2(-0.062758,0.160346),
    vec2(-0.220674,0.957141),
    vec2(0.642692,0.432706),
    vec2(-0.773390,-0.015272),
    vec2(-0.671467,0.246880),
    vec2(0.158051,0.062859),
    vec2(0.806009,0.527232),
    vec2(-0.057620,-0.247071),
    vec2(0.333436,-0.516710),
    vec2(-0.550658,-0.315773),
    vec2(-0.652078,0.589846),
    vec2(0.008818,0.530556),
    vec2(-0.210004,0.519896) 
);

void main() {
    const vec2 pixelCoords = vec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y);
    
    const vec4 positionData = texelFetch(gBufferPosition, ivec2(pixelCoords), 0);

    if (positionData.a < 0.8) {
        imageStore(shadowsImage, ivec2(pixelCoords), vec4(1.0, 0, 0, 1));
        return;
    }

    const vec3 position = positionData.xyz;
    
    const vec3 origin = position;
    const vec3 direction = -dirLight.directionAndIntensity.xyz;
    const vec3 lightTangent   = normalize(cross(direction, vec3(0.0, 1.0, 0.0)));
    const vec3 lightBitangent = normalize(cross(lightTangent, direction));

    uint rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT;
    uint cullMask = 0xff;
    float minDistance = 0.01;
    float maxDistance = 100.0;

    const vec3 noiseImgColor = texture(noiseImage, pixelCoords / textureSize(noiseImage, 0).xy).rgb;
    vec2 noiseSample = BlueNoiseInDisk[frameInfo.frameIndex];

    float angle = fract(noiseImgColor.x * float(frameInfo.frameIndex) * 0.61803398875) * 1.0 * 3.14159;


    const float radius = 0.5 * pow(fract(noiseImgColor.x), 2);

    vec2 diskPoint = vec2(radius * cos(angle) * noiseSample.x, radius * sin(angle) * noiseSample.y);
    diskPoint.x = noiseSample.x * cos(angle) - noiseSample.y * sin(angle);
    diskPoint.y = noiseSample.x * sin(angle) + noiseSample.y * cos(angle);
    diskPoint *= radius;

    const vec3 currentDir = normalize(direction + diskPoint.x * lightTangent + diskPoint.y * lightBitangent);

    traceRayEXT(topLevelAccelerationStructure, rayFlags, cullMask, 0, 0, 0, origin, minDistance, currentDir, maxDistance, 0);
    
    const float shadow = float(!rayResult.isInShadows);
    imageStore(shadowsImage, ivec2(pixelCoords), vec4(shadow, 0, 0, 1));
}
