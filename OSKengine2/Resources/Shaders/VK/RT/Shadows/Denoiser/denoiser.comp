#version 460

layout (local_size_x = 8, local_size_y = 8) in;

layout (set = 0, binding = 0)   uniform sampler2D raytracedShadowsImg;
layout (set = 0, binding = 1, rgba32f) uniform image2D denoisedShadowsImg;
layout (set = 0, binding = 2) uniform sampler2D historicalImg;
layout (set = 0, binding = 3) uniform sampler2D velocityImg;

layout (set = 0, binding = 4) uniform sampler2D currentPositionImg;
layout (set = 0, binding = 5) uniform sampler2D historicalPositionImg;

layout (set = 0, binding = 6) uniform sampler2D currentNormalImg;
layout (set = 0, binding = 7) uniform sampler2D historicalNormalImg;

layout (push_constant) uniform Info {
    vec2 resolution;
} frameInfo;


// Número de frames tope para la convergencia.
// Mayor da mejores resultados.
const float NUM_TEMPORAL_SAMPLES = 60.0;

const float gaussianKernel[5] = float[5](1, 4, 6, 4, 1);

// 5x5 Gaussian-Blur
float GaussianBlur(ivec2 coords) {
    float shadow = 0.0;

    const int radius = 2;
    for (int yy = -radius; yy <= radius; yy++) {
        for (int xx = -radius; xx <= radius; xx++) {
            float k = gaussianKernel[xx + radius] * gaussianKernel[yy + radius] / 256.0;

            shadow += texelFetch(raytracedShadowsImg, coords + ivec2(xx, yy), 0).r * k;
        }
    }

    return shadow;
}

bool SamePlaneOcclussionCheck(vec3 currentPosition, vec3 previousPosition, vec3 currentNormal) {
    // Vector contenido dentro del plano formado entre el punto anterior y el actual.
    const vec3 planeVector = currentPosition - previousPosition;

    // Para que ambos puntos pertenezcan al mismo plano, su producto dot debe ser 0.
    const float dotResult = abs(dot(planeVector, currentNormal));

    return dotResult < 0.1;
}
bool NormalOcclussionCheck(vec3 currentNormal, vec3 previousNormal) {
    return pow(abs(dot(currentNormal, previousNormal)), 2) < 5.0;
}

vec2 Truncate(vec2 vec) {
    return floor(vec);
}

void main() {
    const ivec2 coords = ivec2(gl_GlobalInvocationID);

    if (coords.x > imageSize(denoisedShadowsImg).x || coords.y > imageSize(denoisedShadowsImg).y)
        return;

    const vec2 historicalMotionData = imageLoad(denoisedShadowsImg, coords).zw;
    const vec4 gbufferPositionData = texelFetch(currentPositionImg, coords, 0);
    const vec4 historicalGbufferPositionData = texelFetch(historicalPositionImg, coords, 0);
    const vec4 gbufferNormalData = texelFetch(currentNormalImg, coords, 0);
    const vec4 historicalGbufferNormalData = texelFetch(historicalNormalImg, coords, 0);

    const vec2 normalizedScreenSpaceMotion = texelFetch(velocityImg, ivec2(coords), 0).rg;

    // Cambio en número de píxeles según el motion buffer actual.
    const vec2 currentFrameContDiff = normalizedScreenSpaceMotion * frameInfo.resolution;
    // Cambio en número de píxeles acumulado en frames anteriores.
    const vec2 historicalFramesContDiff = historicalMotionData;

    // Número de frames acumulados en el píxel + 1.0
    float historyLength = 1.0;

    float newShadowWeight = 1.0;
    float historicalShadow = 0.0;

    // Cambio de píxeles en espacio discreto
    vec2 discreteCoordsDiff = Truncate(historicalFramesContDiff + currentFrameContDiff);
    ivec2 historicalCoords = coords + ivec2(discreteCoordsDiff);

    const bool historicalDataWasOnScreen = historicalCoords.x > 0 && historicalCoords.y > 0 && historicalCoords.x < frameInfo.resolution.x && historicalCoords.y < frameInfo.resolution.y;
    const bool previousAreValid = historicalDataWasOnScreen
                        && SamePlaneOcclussionCheck(gbufferPositionData.xyz, historicalGbufferPositionData.xyz, gbufferNormalData.xyz)
                        && NormalOcclussionCheck(gbufferNormalData.xyz, historicalGbufferNormalData.xyz);
    
    if (previousAreValid) {
        const vec4 historicalData = texelFetch(historicalImg, ivec2(historicalCoords), 0);

        historicalShadow = historicalData.r;
        historyLength = historicalData.g + 1.0;
        
        newShadowWeight = 1.0 / historyLength;

        historyLength = min(historyLength, NUM_TEMPORAL_SAMPLES);
    }


    const float newShadows = GaussianBlur(coords);
    const vec2 newHistoricalMotion = fract(historicalFramesContDiff + currentFrameContDiff);
    
    imageStore(denoisedShadowsImg, coords, vec4(mix(historicalShadow, newShadows, newShadowWeight), historyLength, newHistoricalMotion));
}
