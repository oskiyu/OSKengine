#version 460

#include "config.glsl"

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;

layout (set = 0, binding = 0) uniform sampler2D inputImg;
layout (set = 0, binding = 1, FORMAT) uniform image2D outputImg;

layout(push_constant) uniform Info{
    bool first;
} info;

/*

A   B   C
  D   E
F   G   H
  I   J
K   L   M

*/
shared vec4 sharedMemory[LOCAL_SIZE_X + 2 + 2][LOCAL_SIZE_Y + 2 + 2];

vec3 PowVec3(vec3 v, float p)
{
    return vec3(pow(v.x, p), pow(v.y, p), pow(v.z, p));
}

const float invGamma = 1.0 / 2.2;
vec3 ToSRGB(vec3 v) { return PowVec3(v, invGamma); }

float RGBToLuminance(vec3 col)
{
    return dot(col, vec3(0.2126f, 0.7152f, 0.0722f));
}

float KarisAverage(vec3 col)
{
    // Formula is 1 / (1 + luma)
    float luma = RGBToLuminance(ToSRGB(col)) * 0.25f;
    return 1.0f / (1.0f + luma);
}

void main() {
    const vec2 previousResolution = textureSize(inputImg, 0); // ?
    const vec2 nextResolution = imageSize(outputImg);

    const vec2 currentCoords = vec2(gl_GlobalInvocationID.xy);
    
    if (currentCoords.x > nextResolution.x || currentCoords.y > nextResolution.y)
        return;
    
    const vec2 previousCoordinates = currentCoords * 2.0 + 0.5; //(previousResolution / nextResolution) * currentCoords;

    const vec2 sourcePixelSize = 1.0 / textureSize(inputImg, 0);

#ifdef USE_SHARED_MEMORY

    const int numSquaresAxisX = (LOCAL_SIZE_X + 2 + 2) / 2;
    const int numSquaresAxisY = (LOCAL_SIZE_Y + 2 + 2) / 2;

	if (gl_LocalInvocationID.x < numSquaresAxisX && gl_LocalInvocationID.y < numSquaresAxisY) {
        const ivec2 workgroupCoordinates = ivec2(gl_WorkGroupID.xy) * ivec2(LOCAL_SIZE_X, LOCAL_SIZE_Y);
        const ivec2 threadCoordinates = ivec2(gl_LocalInvocationID.xy);
        
        const ivec2 previousCoordinates = workgroupCoordinates + threadCoordinates * ivec2(2, 2) - ivec2(2, 2);
        const ivec2 squareCoordinates = threadCoordinates * ivec2(2, 2) - ivec2(2, 2);

        for (int x = 0; x < 2; x++) {
            for (int y = 0; y < 2; y++) {
                const vec2 previousCoordinates = (vec2(previousCoordinates) + vec2(x, y)) * 2 + 0.5;
                sharedMemory[squareCoordinates.x + x + 2][squareCoordinates.y + y + 2] = texture(inputImg, previousCoordinates * sourcePixelSize);
            }
        }
    }

    barrier();

    const ivec2 sharedCoords = ivec2(gl_LocalInvocationID.xy) + ivec2(2, 2);

    const vec4 A = sharedMemory[sharedCoords.x - 2][sharedCoords.y - 2];
    const vec4 B = sharedMemory[sharedCoords.x + 0][sharedCoords.y - 2];
    const vec4 C = sharedMemory[sharedCoords.x + 2][sharedCoords.y - 2];
    
    const vec4 D = sharedMemory[sharedCoords.x - 1][sharedCoords.y - 1];
    const vec4 E = sharedMemory[sharedCoords.x + 1][sharedCoords.y - 1];

    const vec4 F = sharedMemory[sharedCoords.x - 2][sharedCoords.y + 0];
    const vec4 G = sharedMemory[sharedCoords.x + 0][sharedCoords.y + 0];
    const vec4 H = sharedMemory[sharedCoords.x + 2][sharedCoords.y + 0];

    const vec4 I = sharedMemory[sharedCoords.x - 1][sharedCoords.y + 1];
    const vec4 J = sharedMemory[sharedCoords.x + 1][sharedCoords.y + 1];

    const vec4 K = sharedMemory[sharedCoords.x - 2][sharedCoords.y + 2];
    const vec4 L = sharedMemory[sharedCoords.x + 0][sharedCoords.y + 2];
    const vec4 M = sharedMemory[sharedCoords.x + 2][sharedCoords.y + 2];

#else

    const vec4 A = texture(inputImg, (previousCoordinates + vec2(-2, -2)) * sourcePixelSize);
    const vec4 B = texture(inputImg, (previousCoordinates + vec2( 0, -2)) * sourcePixelSize);
    const vec4 C = texture(inputImg, (previousCoordinates + vec2( 2, -2)) * sourcePixelSize);
    
    const vec4 D = texture(inputImg, (previousCoordinates + vec2(-1, -1)) * sourcePixelSize);
    const vec4 E = texture(inputImg, (previousCoordinates + vec2( 1, -1)) * sourcePixelSize);
    
    const vec4 F = texture(inputImg, (previousCoordinates + vec2(-2,  0)) * sourcePixelSize);
    const vec4 G = texture(inputImg, (previousCoordinates + vec2( 0,  0)) * sourcePixelSize);
    const vec4 H = texture(inputImg, (previousCoordinates + vec2( 2,  0)) * sourcePixelSize);
    
    const vec4 I = texture(inputImg, (previousCoordinates + vec2(-1,  1)) * sourcePixelSize);
    const vec4 J = texture(inputImg, (previousCoordinates + vec2( 1,  1)) * sourcePixelSize);
    
    const vec4 K = texture(inputImg, (previousCoordinates + vec2(-2,  2)) * sourcePixelSize);
    const vec4 L = texture(inputImg, (previousCoordinates + vec2( 0,  2)) * sourcePixelSize);
    const vec4 M = texture(inputImg, (previousCoordinates + vec2( 2,  2)) * sourcePixelSize);
    
#endif


    vec4 groupA = (A + B + F + G) * 0.25 * 0.125;
    vec4 groupB = (B + C + G + H) * 0.25 * 0.125;
    vec4 groupC = (F + G + K + L) * 0.25 * 0.125;
    vec4 groupD = (G + H + L + M) * 0.25 * 0.125;
    vec4 groupE = (D + E + I + J) * 0.25 * 0.5;

    if (info.first) {
        groupA *= KarisAverage(groupA.rgb);
        groupB *= KarisAverage(groupB.rgb);
        groupC *= KarisAverage(groupC.rgb);
        groupD *= KarisAverage(groupD.rgb);
        groupE *= KarisAverage(groupE.rgb);
    }

    const vec4 color = groupA
                     + groupB
                     + groupC
                     + groupD
                     + groupE;

    imageStore(outputImg, ivec2(currentCoords.xy), color);
}
