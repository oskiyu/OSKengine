#version 460

layout (local_size_x = 4, local_size_y = 4) in;

layout (set = 0, binding = 0) uniform sampler2D inputImg;
layout (set = 0, binding = 1, rgba32f) uniform image2D outputImg;

layout (push_constant) uniform Info{
    vec4 infos;
} info;

// A B C
// D E F
// G H I
void main() {
    vec4 color = vec4(0);

    const vec2 previousResolution = info.infos.xy;
    const vec2 nextResolution = info.infos.zw;

    const vec2 currentCoords = vec2(gl_GlobalInvocationID.xy);
    
    if (currentCoords.x > nextResolution.x || currentCoords.y > nextResolution.y)
        return;
    
    const vec2 previousCoordinates = currentCoords * 0.5; //(previousResolution / nextResolution) * currentCoords;

    const float radius = 1;
    const vec2 sourcePixelSize = 1.0 / textureSize(inputImg, 0);

    color += texture(inputImg, (previousCoordinates + vec2( 0,  0) * radius) * sourcePixelSize) * 4;
    
    color += texture(inputImg, (previousCoordinates + vec2(-1,  0) * radius) * sourcePixelSize) * 2;
    color += texture(inputImg, (previousCoordinates + vec2( 1,  0) * radius) * sourcePixelSize) * 2;
    color += texture(inputImg, (previousCoordinates + vec2( 0, -1) * radius) * sourcePixelSize) * 2;
    color += texture(inputImg, (previousCoordinates + vec2( 0,  1) * radius) * sourcePixelSize) * 2;


    color += texture(inputImg, (previousCoordinates + vec2( 1,  1) * radius) * sourcePixelSize) * 1;
    color += texture(inputImg, (previousCoordinates + vec2(-1,  1) * radius) * sourcePixelSize) * 1;
    color += texture(inputImg, (previousCoordinates + vec2(-1, -1) * radius) * sourcePixelSize) * 1;
    color += texture(inputImg, (previousCoordinates + vec2( 1, -1) * radius) * sourcePixelSize) * 1;

    color /= 16.0;

    imageStore(outputImg, ivec2(currentCoords.xy), color);
}
